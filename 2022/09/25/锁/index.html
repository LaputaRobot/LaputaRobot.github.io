<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>锁 | Laputa's Blog</title><meta name="author" content="Laputa,gbyue@outlook.com"><meta name="copyright" content="Laputa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="事务的隔离性由锁实现 锁结构当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。  锁内存结构InnoDB 存储引擎中的 锁结构 如下：   锁所在的事务信息 ：  不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个 事务的信息。  此 锁所在的事务信息 在内存结构中只是一个">
<meta property="og:type" content="article">
<meta property="og:title" content="锁">
<meta property="og:url" content="https://blog.ygbs.site/2022/09/25/%E9%94%81/index.html">
<meta property="og:site_name" content="Laputa&#39;s Blog">
<meta property="og:description" content="事务的隔离性由锁实现 锁结构当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。  锁内存结构InnoDB 存储引擎中的 锁结构 如下：   锁所在的事务信息 ：  不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个 事务的信息。  此 锁所在的事务信息 在内存结构中只是一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/%E4%B8%8B%E8%BD%BD%20%283%29.jpg">
<meta property="article:published_time" content="2022-09-25T12:46:49.152Z">
<meta property="article:modified_time" content="2022-09-25T12:48:19.330Z">
<meta property="article:author" content="Laputa">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/%E4%B8%8B%E8%BD%BD%20%283%29.jpg"><link rel="shortcut icon" href="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/fac.png"><link rel="canonical" href="https://blog.ygbs.site/2022/09/25/%E9%94%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-25 20:48:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/l_a_p_u_t_a_by_blargen69_dbaa31z-pre.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/%E4%B8%8B%E8%BD%BD%20%283%29.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Laputa's Blog"><span class="site-name">Laputa's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-25T12:46:49.152Z" title="发表于 2022-09-25 20:46:49">2022-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-25T12:48:19.330Z" title="更新于 2022-09-25 20:48:19">2022-09-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MySQL%E9%94%81/">MySQL锁</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>事务的<code>隔离性</code>由<code>锁</code>实现</p>
<h1 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h1><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。</p>
<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925113522813.png" alt="锁结构"></p>
<h2 id="锁内存结构"><a href="#锁内存结构" class="headerlink" title="锁内存结构"></a>锁内存结构</h2><p>InnoDB 存储引擎中的 锁结构 如下：</p>
<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925182029213.png" alt="锁内存结构"></p>
<ol>
<li><p>锁所在的事务信息 ： </p>
<p>不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个 事务的信息。 </p>
<p>此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比 方说事务id等。</p>
</li>
<li><p>索引信息 ：</p>
</li>
</ol>
<p>   对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。 </p>
<ol start="3">
<li>表锁／行锁信息 ： 表锁结构 和 行锁结构 在这个位置的内容是不同的：</li>
</ol>
<ul>
<li><p>表锁</p>
<p>记载着是对哪个表加的锁，还有其他的一些信息。</p>
</li>
<li><p>行锁</p>
<p>记载了三个重要的信息： </p>
<p>Space ID ：记录所在表空间。 </p>
<p>Page Number ：记录所在页号。 </p>
<p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 n_bits 属性代表使用了多少比特位。</p>
</li>
</ul>
<ol start="4">
<li><p>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：</p>
<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925182558233.png" alt="type-mode各位置含义"></p>
<ul>
<li><p>锁的模式（ lock_mode ），占用低4位，可选的值如下：</p>
<ul>
<li>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。 </li>
<li>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。</li>
<li>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。 </li>
<li>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。 </li>
<li>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。</li>
</ul>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。 </p>
</li>
<li><p>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<ul>
<li>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。 </li>
<li>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在 lock_type 的值为 LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型： </p>
<ul>
<li>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。</li>
<li>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。</li>
<li>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录 锁 。 </li>
<li>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入 意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><p>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32 位的数字中： </p>
</li>
<li><p>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。</p>
</li>
</ul>
</li>
<li><p>其他信息</p>
<p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>
</li>
<li><p>一堆比特位 </p>
<p>如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性 表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的 heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即<strong>一个比特位映射 到页内的一条记录</strong>。</p>
</li>
</ol>
<h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925113832805.png" alt="锁分类"></p>
<h2 id="从操作类型划分：读锁、写锁"><a href="#从操作类型划分：读锁、写锁" class="headerlink" title="从操作类型划分：读锁、写锁"></a>从操作类型划分：读锁、写锁</h2><ul>
<li><p>读锁、共享锁、S锁：针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</p>
</li>
<li><p>写锁、排他锁、X锁：当前写操作没有完成前，它会阻断其他写锁和读锁。</p>
</li>
</ul>
<h2 id="从粒度划分：表级锁、页级锁、行锁"><a href="#从粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从粒度划分：表级锁、页级锁、行锁"></a>从粒度划分：表级锁、页级锁、行锁</h2><h3 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h3><h4 id="1-1、表级别X锁、S锁"><a href="#1-1、表级别X锁、S锁" class="headerlink" title="1.1、表级别X锁、S锁"></a>1.1、表级别X锁、S锁</h4><p>在对某个表执行&#96;SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p>
<p>在对某个表执行一些诸如ALTERT ABLE、DROP TABLE这类的DDL语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁（英文名：Metadata Locks，简称MDL）结构来实现的。</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的S锁和X锁。只会在一些特殊情况下，比方说崩溃恢复过程中用到。比如，在系统变量autocommit&#x3D;0，innodb_table_locks&#x3D;1时，手动获取InnoDB存储引擎提供的表t的S锁或者X锁可以这么写：</p>
<p>LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁。</p>
<p>LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁。</p>
<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925114933942.png" alt="表锁互斥规则"></p>
<h4 id="1-2、意向锁（intention-lock）"><a href="#1-2、意向锁（intention-lock）" class="headerlink" title="1.2、意向锁（intention lock）"></a>1.2、意向锁（intention lock）</h4><ul>
<li>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><br><span class="line">SELECT column FROM table ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<ul>
<li>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><br><span class="line">SELECT column FROM table ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>意向锁是由存储引擎自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前， InooDB 会先获取该数据行所在数据表的对应意向锁 。</p>
</blockquote>
<p>意向锁不会与行级的共享 &#x2F; 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p>
<p><strong>结论：</strong></p>
<ol>
<li>InnoDB 支持 多粒度锁 ，特定场景下，行级锁可以与表级锁共存。 </li>
<li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， 意向锁会与 共享锁 &#x2F; 排他锁 互斥 。</li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li>
<li>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</li>
</ol>
<h4 id="1-3-、自增锁（AUTO-INC锁）"><a href="#1-3-、自增锁（AUTO-INC锁）" class="headerlink" title="1.3 、自增锁（AUTO-INC锁）"></a>1.3 、自增锁（AUTO-INC锁）</h4><p>所有插入数据的方式总共分为三类，分别是“Simple inserts”，“ Bulk inserts ”和“ Mixed-mode inserts ”。</p>
<ol>
<li><p>“Simple inserts” （简单插入） </p>
<p>可以预先确定要插入的行数（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES()和REPLACE语句。</p>
</li>
<li><p>“Bulk inserts”（批量插入）</p>
<p>事先不知道要插入的行数（和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列 分配一个新值。 </p>
</li>
<li><p>“Mixed-mode inserts” （混合模式插入）</p>
</li>
</ol>
<p>   这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。</p>
<p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p>
<p>（1）innodb_autoinc_lock_mode &#x3D; 0(“传统”锁定模式)</p>
<p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会限制并发 能力。</p>
<p>（2）innodb_autoinc_lock_mode &#x3D; 1(“连续”锁定模式)(8.0之前默认)</p>
<p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。</p>
<p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的 自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用 表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p>
<p>（3）innodb_autoinc_lock_mode &#x3D; 2(“交错”锁定模式)（8.0开始默认） </p>
<p>在此锁定模式下，自动递增值保证在所有并发执行的所有类型的insert语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。</p>
<h4 id="1-4、元数据锁（MDL锁）"><a href="#1-4、元数据锁（MDL锁）" class="headerlink" title="1.4、元数据锁（MDL锁）"></a>1.4、元数据锁（MDL锁）</h4><p> MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<h3 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a>2. InnoDB中的行锁</h3><h4 id="1-1、记录锁（Record-Locks）"><a href="#1-1、记录锁（Record-Locks）" class="headerlink" title="1.1、记录锁（Record Locks）"></a>1.1、记录锁（Record Locks）</h4><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： <code>LOCK_REC_NOT_GAP</code> 。比如我们把id值为8的 那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<h4 id="1-2、间隙锁（Gap-Lock）"><a href="#1-2、间隙锁（Gap-Lock）" class="headerlink" title="1.2、间隙锁（Gap Lock）"></a>1.2、间隙锁（Gap Lock）</h4><p>MySQL在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为：<code>LOCK_GAP</code> ，我们可以简称为 gap锁 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p>
<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925180137364.png" alt="image-20220925180137364"></p>
<h4 id="1-3、-临键锁（Next-Key-Locks）"><a href="#1-3、-临键锁（Next-Key-Locks）" class="headerlink" title="1.3、 临键锁（Next-Key Locks）"></a>1.3、 临键锁（Next-Key Locks）</h4><p>有时候我们既想锁住某条记录 ，又想阻止其他事务在该记录前边的间隙插入新记录 ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： <code>LOCK_ORDINARY</code> ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， <strong>innodb默认的锁就是Next-Key locks</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from student where id &lt;=8 and id &gt; 3 for update;</span><br></pre></td></tr></table></figure>



<h4 id="1-4、插入意向锁（Insert-Intention-Locks）"><a href="#1-4、插入意向锁（Insert-Intention-Locks）" class="headerlink" title="1.4、插入意向锁（Insert Intention Locks）"></a>1.4、插入意向锁（Insert Intention Locks）</h4><p>我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 （ next-key锁 也包含 gap锁 ），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是InnoDB规 定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个 间隙 中 插入 新记录，但是 现在在等待。InnoDB就把这种类型的锁命名为 Insert Intention Locks ，官方的类型名称为： <code>LOCK_INSERT_INTENTION</code>，我们称为 插入意向锁 。插入意向锁是一种 Gap锁 ，不是意向锁，在insert 操作时产生。</p>
<p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁 。</p>
<p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</strong>。</p>
<h3 id="3、页锁"><a href="#3、页锁" class="headerlink" title="3、页锁"></a>3、页锁</h3><h3 id="4、全局锁"><a href="#4、全局锁" class="headerlink" title="4、全局锁"></a>4、全局锁</h3><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。 全局锁的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure>



<h2 id="从对待锁的态度划分-乐观锁、悲观锁"><a href="#从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="从对待锁的态度划分:乐观锁、悲观锁"></a>从对待锁的态度划分:乐观锁、悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h2 id="按加锁的方式划分：显式锁、隐式锁"><a href="#按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="按加锁的方式划分：显式锁、隐式锁"></a>按加锁的方式划分：显式锁、隐式锁</h2><h3 id="1、隐式锁"><a href="#1、隐式锁" class="headerlink" title="1、隐式锁"></a>1、隐式锁</h3><ul>
<li><strong>情景一：</strong>对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务 id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li>
<li><strong>情景二</strong>：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</li>
</ul>
<p>隐式锁的逻辑过程如下： </p>
<p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p>
<p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活 动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)。 </p>
<p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。 </p>
<p>D. 等待加锁成功，被唤醒，或者超时。 </p>
<p>E. 写数据，并将自己的trx_id写入trx_id字段。</p>
<h3 id="2、显式锁"><a href="#2、显式锁" class="headerlink" title="2、显式锁"></a>2、显式锁</h3><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如： 显示加共享锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... lock in share mode</span><br></pre></td></tr></table></figure>

<p>显示加排它锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select .... for update</span><br></pre></td></tr></table></figure>

<h1 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h1><p>关于MySQL锁的监控，我们一般可以通过检查InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;innodb_row_lock%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925194657695.png" alt="image-20220925194657695"></p>
<p>对各个状态量的说明如下：</p>
<ul>
<li>Innodb_row_lock_current_waits：当前正在等待锁定的数量； </li>
<li>Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长） </li>
<li>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长） </li>
<li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间； </li>
<li>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<h2 id="其他监控方法"><a href="#其他监控方法" class="headerlink" title="其他监控方法"></a>其他监控方法</h2><p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是 INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。 </p>
<p>MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。 </p>
<p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 performance_schema.data_locks ，可 以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同， performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p>
<p>同时，information_schema.INNODB_LOCK_WAITS也被 performance_schema.data_lock_waits 所代替。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	E(MySQL5.7)--&gt;F(MySQL8.0)</span><br><span class="line">	A(information_schema.INNODB_LOCKS)--&gt;B(performance_schema.data_locks)</span><br><span class="line">	C(information_schema.INNODB_LOCK_WAITS)--&gt;D(performance_schema.data_lock_waits)</span><br></pre></td></tr></table></figure>

<p>（1）查询正在被锁阻塞的sql语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">trx_id：唯一事务id号，只读事务和非锁事务是不会创建id的。</span><br><span class="line">TRX_WEIGHT：事务的高度，代表修改的行数（不一定准确）和被事务锁住的行数。为了解决死锁，innodb会选择一个高度最小的事务来当做牺牲品进行回滚。已经被更改的非交易型表的事务权重比其他事务高，即使改变的行和锁住的行比其他事务低。</span><br><span class="line">TRX_STATE：事务的执行状态，值一般分为：RUNNING, LOCK WAIT, ROLLING BACK, and COMMITTING.</span><br><span class="line">TRX_STARTED：事务的开始时间</span><br><span class="line">TRX_REQUESTED_LOCK_ID:如果trx_state是lockwait,显示事务当前等待锁的id，不是则为空。想要获取锁的信息，根据该lock_id，以innodb_locks表中lock_id列匹配条件进行查询，获取相关信息。</span><br><span class="line">TRX_WAIT_STARTED：如果trx_state是lockwait,该值代表事务开始等待锁的时间；否则为空。</span><br><span class="line">TRX_MYSQL_THREAD_ID：mysql线程id。想要获取该线程的信息，根据该thread_id，以INFORMATION_SCHEMA.PROCESSLIST表的id列为匹配条件进行查询。</span><br><span class="line">TRX_QUERY：事务正在执行的sql语句。</span><br><span class="line">TRX_OPERATION_STATE：事务当前的操作状态，没有则为空。</span><br><span class="line">TRX_TABLES_IN_USE：事务在处理当前sql语句使用innodb引擎表的数量。</span><br><span class="line">TRX_TABLES_LOCKED：当前sql语句有行锁的innodb表的数量。（因为只是行锁，不是表锁，表仍然可以被多个事务读和写）</span><br><span class="line">TRX_LOCK_STRUCTS：事务保留锁的数量。</span><br><span class="line">TRX_LOCK_MEMORY_BYTES：在内存中事务索结构占得空间大小。</span><br><span class="line">TRX_ROWS_LOCKED：事务行锁最准确的数量。这个值可能包括对于事务在物理上存在，实际不可见的删除标记的行。</span><br><span class="line">TRX_ROWS_MODIFIED：事务修改和插入的行数</span><br><span class="line">TRX_CONCURRENCY_TICKETS：该值代表当前事务在被清掉之前可以多少工作，由 innodb_concurrency_tickets系统变量值指定。</span><br><span class="line">TRX_ISOLATION_LEVEL：事务隔离等级。</span><br><span class="line">TRX_UNIQUE_CHECKS：当前事务唯一性检查启用还是禁用。当批量数据导入时，这个参数是关闭的。</span><br><span class="line">TRX_FOREIGN_KEY_CHECKS：当前事务的外键坚持是启用还是禁用。当批量数据导入时，这个参数是关闭的。</span><br><span class="line">TRX_LAST_FOREIGN_KEY_ERROR：最新一个外键错误信息，没有则为空。</span><br><span class="line">TRX_ADAPTIVE_HASH_LATCHED：自适应哈希索引是否被当前事务阻塞。当自适应哈希索引查找系统分区，一个单独的事务不会阻塞全部的自适应hash索引。自适应hash索引分区通过 innodb_adaptive_hash_index_parts参数控制，默认值为8。</span><br><span class="line">TRX_ADAPTIVE_HASH_TIMEOUT：是否为了自适应hash索引立即放弃查询锁，或者通过调用mysql函数保留它。当没有自适应hash索引冲突，该值为0并且语句保持锁直到结束。在冲突过程中，该值被计数为0，每句查询完之后立即释放门闩。当自适应hash索引查询系统被分区（由 innodb_adaptive_hash_index_parts参数控制），值保持为0。</span><br><span class="line">TRX_IS_READ_ONLY：值为1表示事务是read only。</span><br><span class="line">TRX_AUTOCOMMIT_NON_LOCKING：值为1表示事务是一个select语句，该语句没有使用for update或者shared mode锁，并且执行开启了autocommit，因此事务只包含一个语句。当TRX_AUTOCOMMIT_NON_LOCKING和TRX_IS_READ_ONLY同时为1，innodb通过降低事务开销和改变表数据库来优化事务。</span><br></pre></td></tr></table></figure>



<p>（2）查询锁的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * from performance_schema.data_locks\G;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ENGINE：持有或请求锁定的存储引擎</span><br><span class="line">ENGINE_LOCK_ID：存储引擎持有或请求的锁的ID，锁ID格式是内部的，随时可能更改。</span><br><span class="line">ENGINE_TRANSACTION_ID：请求锁定的事务存储引擎内部ID，可以将其视为锁的所有者</span><br><span class="line">THREAD_ID：对应事务的线程ID，如果需要获取更详细的信息，需要关联threads表的THREAD_ID</span><br><span class="line">EVENT_ID：指明造成锁的EVENT_ID，THREAD_ID+EVENT_ID对应parent EVENT，可以在以下几张表内获得信息</span><br><span class="line">events_waits_xx表查看等待事件</span><br><span class="line">events_stages_xxx查看到了哪个阶段</span><br><span class="line">events_statements_xx表查看对应的SQL语句</span><br><span class="line">events_transactions_current对应查看事务信息</span><br><span class="line">OBJECT_SCHEMA：对应锁表的schema名称</span><br><span class="line">OBJECT_NAME：对应锁的表名</span><br><span class="line">PARTITION_NAME：对应锁的分区名</span><br><span class="line">SUBPARTITION_NAME：对应锁的子分区名</span><br><span class="line">INDEX_NAME：锁对应的索引名称，InnoDB表不会为NULL</span><br><span class="line">OBJECT_INSTANCE_BEGIN：锁对应的内存地址</span><br><span class="line">LOCK_TYPE：对应的锁类型，对InnoDB而言，可为表锁或者行锁</span><br><span class="line">LOCK_MODE：锁模式，对应值可能为S[,GAP], X[, GAP], IS[,GAP], IX[,GAP], AUTO_INC和UNKNOWN</span><br><span class="line">LOCK_STATUS：锁状态，可能为GRANTED或者WAITING</span><br><span class="line">LOCK_DATA：锁对应的数据，例如如果锁定的是主键，那么该列对应的就是加锁的主键值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- col1为辅助索引，索引名为c</span><br><span class="line">select * from test where test.col1&gt;=10 and test.col1&lt;11 for update;</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925201840219.png" alt="image-20220925201840219"></p>
<p>（3）查询锁等待情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM data_lock_waits\G;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ENGINE：请求的锁的引擎</span><br><span class="line">REQUESTING_ENGINE_LOCK_ID：请求的锁在存储引擎中的锁ID</span><br><span class="line">REQUESTING_ENGINE_TRANSACTION_ID：请求锁的事务对应的事务ID</span><br><span class="line">REQUESTING_THREAD_ID：请求锁的线程ID</span><br><span class="line">REQUESTING_EVENT_ID：请求锁的EVENT ID</span><br><span class="line">REQUESTING_OBJECT_INSTANCE_BEGIN：请求的锁的内存地址</span><br><span class="line">BLOCKING_ENGINE_LOCK_ID：阻塞的锁的ID，对应data_locks表的ENGINE_LOCK_ID列</span><br><span class="line">BLOCKING_ENGINE_TRANSACTION_ID：锁阻塞的事务ID</span><br><span class="line">BLOCKING_THREAD_ID：锁阻塞的线程ID</span><br><span class="line">BLOCKING_EVENT_ID：锁阻塞的EVENT ID</span><br><span class="line">BLOCKING_OBJECT_INSTANCE_BEGIN：阻塞的锁内存地址</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into test values(8,8,8);</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925201633279.png" alt="image-20220925201633279"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://blog.ygbs.site">Laputa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.ygbs.site/2022/09/25/%E9%94%81/">https://blog.ygbs.site/2022/09/25/%E9%94%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ygbs.site" target="_blank">Laputa's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/%E4%B8%8B%E8%BD%BD%20%283%29.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/09/09/Queue/" title="Queue"><img class="cover" src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/%E4%B8%8B%E8%BD%BD%20%284%29.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Queue</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/l_a_p_u_t_a_by_blargen69_dbaa31z-pre.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Laputa</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LaputaRobot" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2524777478@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=2524777478&amp;Site=&amp;Menu=yes" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">锁结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">锁内存结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">锁分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%9A%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">从操作类型划分：读锁、写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E9%A1%B5%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">从粒度划分：表级锁、页级锁、行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%A1%A8%E9%94%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">1、表锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E8%A1%A8%E7%BA%A7%E5%88%ABX%E9%94%81%E3%80%81S%E9%94%81"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1.1、表级别X锁、S锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88intention-lock%EF%BC%89"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">1.2、意向锁（intention lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E3%80%81%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%88AUTO-INC%E9%94%81%EF%BC%89"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">1.3 、自增锁（AUTO-INC锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E3%80%81%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88MDL%E9%94%81%EF%BC%89"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">1.4、元数据锁（MDL锁）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-InnoDB%E4%B8%AD%E7%9A%84%E8%A1%8C%E9%94%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. InnoDB中的行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Locks%EF%BC%89"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">1.1、记录锁（Record Locks）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">1.2、间隙锁（Gap Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E3%80%81-%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">1.3、 临键锁（Next-Key Locks）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E3%80%81%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Locks%EF%BC%89"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">1.4、插入意向锁（Insert Intention Locks）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E9%A1%B5%E9%94%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">3、页锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">4、全局锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%92%E5%88%86-%E4%B9%90%E8%A7%82%E9%94%81%E3%80%81%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">从对待锁的态度划分:乐观锁、悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">2.3.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%92%E5%88%86%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%94%81%E3%80%81%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">按加锁的方式划分：显式锁、隐式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%9A%90%E5%BC%8F%E9%94%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">1、隐式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%98%BE%E5%BC%8F%E9%94%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">2、显式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%9B%91%E6%8E%A7"><span class="toc-number">3.</span> <span class="toc-text">锁监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">其他监控方法</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Laputa</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to Laputa's Blog <a target="_blank" rel="noopener" href="https://blog.hellook.top/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>