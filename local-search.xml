<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/2022/09/25/%E9%94%81/"/>
    <url>/2022/09/25/%E9%94%81/</url>
    
    <content type="html"><![CDATA[<p>事务的<code>隔离性</code>由<code>锁</code>实现</p><h1 id="锁结构"><a href="#锁结构" class="headerlink" title="锁结构"></a>锁结构</h1><p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925113522813.png" alt="锁结构"></p><h2 id="锁内存结构"><a href="#锁内存结构" class="headerlink" title="锁内存结构"></a>锁内存结构</h2><p>InnoDB 存储引擎中的 锁结构 如下：</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925182029213.png" alt="锁内存结构"></p><ol><li><p>锁所在的事务信息 ： </p><p>不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个 事务的信息。 </p><p>此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比 方说事务id等。</p></li><li><p>索引信息 ：</p></li></ol><p>   对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。 </p><ol start="3"><li>表锁／行锁信息 ： 表锁结构 和 行锁结构 在这个位置的内容是不同的：</li></ol><ul><li><p>表锁</p><p>记载着是对哪个表加的锁，还有其他的一些信息。</p></li><li><p>行锁</p><p>记载了三个重要的信息： </p><p>Space ID ：记录所在表空间。 </p><p>Page Number ：记录所在页号。 </p><p>n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同 的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个 n_bits 属性代表使用了多少比特位。</p></li></ul><ol start="4"><li><p>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925182558233.png" alt="type-mode各位置含义"></p><ul><li><p>锁的模式（ lock_mode ），占用低4位，可选的值如下：</p><ul><li>LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。 </li><li>LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。</li><li>LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。 </li><li>LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。 </li><li>LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。</li></ul><p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和 LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。 </p></li><li><p>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p><ul><li>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。 </li><li>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li></ul></li><li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在 lock_type 的值为 LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型： </p><ul><li>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。</li><li>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。</li><li>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录 锁 。 </li><li>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入 意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li></ul></li><li><p>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32 位的数字中： </p></li><li><p>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也 就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 is_waiting 为 false ，也就是当前事务获取锁成功。</p></li></ul></li><li><p>其他信息</p><p>为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p></li><li><p>一堆比特位 </p><p>如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性 表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的 heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结 构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即<strong>一个比特位映射 到页内的一条记录</strong>。</p></li></ol><h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925113832805.png" alt="锁分类"></p><h2 id="从操作类型划分：读锁、写锁"><a href="#从操作类型划分：读锁、写锁" class="headerlink" title="从操作类型划分：读锁、写锁"></a>从操作类型划分：读锁、写锁</h2><ul><li><p>读锁、共享锁、S锁：针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。</p></li><li><p>写锁、排他锁、X锁：当前写操作没有完成前，它会阻断其他写锁和读锁。</p></li></ul><h2 id="从粒度划分：表级锁、页级锁、行锁"><a href="#从粒度划分：表级锁、页级锁、行锁" class="headerlink" title="从粒度划分：表级锁、页级锁、行锁"></a>从粒度划分：表级锁、页级锁、行锁</h2><h3 id="1、表锁"><a href="#1、表锁" class="headerlink" title="1、表锁"></a>1、表锁</h3><h4 id="1-1、表级别X锁、S锁"><a href="#1-1、表级别X锁、S锁" class="headerlink" title="1.1、表级别X锁、S锁"></a>1.1、表级别X锁、S锁</h4><p>在对某个表执行&#96;SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p><p>在对某个表执行一些诸如ALTERT ABLE、DROP TABLE这类的DDL语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁（英文名：Metadata Locks，简称MDL）结构来实现的。</p><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的S锁和X锁。只会在一些特殊情况下，比方说崩溃恢复过程中用到。比如，在系统变量autocommit&#x3D;0，innodb_table_locks&#x3D;1时，手动获取InnoDB存储引擎提供的表t的S锁或者X锁可以这么写：</p><p>LOCK TABLES t READ：InnoDB存储引擎会对表t加表级别的S锁。</p><p>LOCK TABLES t WRITE：InnoDB存储引擎会对表t加表级别的X锁。</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925114933942.png" alt="表锁互斥规则"></p><h4 id="1-2、意向锁（intention-lock）"><a href="#1-2、意向锁（intention-lock）" class="headerlink" title="1.2、意向锁（intention lock）"></a>1.2、意向锁（intention lock）</h4><ul><li>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。<br>SELECT column FROM table ... LOCK IN SHARE MODE;<br></code></pre></td></tr></table></figure><ul><li>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。<br>SELECT column FROM table ... FOR UPDATE;<br></code></pre></td></tr></table></figure><blockquote><p>意向锁是由存储引擎自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前， InooDB 会先获取该数据行所在数据表的对应意向锁 。</p></blockquote><p>意向锁不会与行级的共享 &#x2F; 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。（不然我们直接用普通的表锁就行了）</p><p><strong>结论：</strong></p><ol><li>InnoDB 支持 多粒度锁 ，特定场景下，行级锁可以与表级锁共存。 </li><li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， 意向锁会与 共享锁 &#x2F; 排他锁 互斥 。</li><li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。</li><li>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</li></ol><h4 id="1-3-、自增锁（AUTO-INC锁）"><a href="#1-3-、自增锁（AUTO-INC锁）" class="headerlink" title="1.3 、自增锁（AUTO-INC锁）"></a>1.3 、自增锁（AUTO-INC锁）</h4><p>所有插入数据的方式总共分为三类，分别是“Simple inserts”，“ Bulk inserts ”和“ Mixed-mode inserts ”。</p><ol><li><p>“Simple inserts” （简单插入） </p><p>可以预先确定要插入的行数（当语句被初始处理时）的语句。包括没有嵌套子查询的单行和多行INSERT…VALUES()和REPLACE语句。</p></li><li><p>“Bulk inserts”（批量插入）</p><p>事先不知道要插入的行数（和所需自动递增值的数量）的语句。比如 INSERT … SELECT ， REPLACE … SELECT 和 LOAD DATA 语句，但不包括纯INSERT。 InnoDB在每处理一行，为AUTO_INCREMENT列 分配一个新值。 </p></li><li><p>“Mixed-mode inserts” （混合模式插入）</p></li></ol><p>   这些是“Simple inserts”语句但是指定部分新行的自动递增值。例如 INSERT INTO teacher (id,name) VALUES (1,’a’), (NULL,’b’), (5,’c’), (NULL,’d’); 只是指定了部分id的值。另一种类型的“混合模式插入”是 INSERT … ON DUPLICATE KEY UPDATE 。</p><p>innodb_autoinc_lock_mode有三种取值，分别对应与不同锁定模式：</p><p>（1）innodb_autoinc_lock_mode &#x3D; 0(“传统”锁定模式)</p><p>在此锁定模式下，所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，用于插入具有 AUTO_INCREMENT列的表。在binlog中重放的时候，可以保证 master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的 时候，对于AUTO-INC锁的争夺会限制并发 能力。</p><p>（2）innodb_autoinc_lock_mode &#x3D; 1(“连续”锁定模式)(8.0之前默认)</p><p>在这个模式下，“bulk inserts”仍然使用AUTO-INC表级锁，并保持到语句结束。</p><p>对于“Simple inserts”（要插入的行数事先已知），则通过在 mutex（轻量锁） 的控制下获得所需数量的 自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用 表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则“Simple inserts”等待AUTO-INC锁，如同它是一个“bulk inserts”。</p><p>（3）innodb_autoinc_lock_mode &#x3D; 2(“交错”锁定模式)（8.0开始默认） </p><p>在此锁定模式下，自动递增值保证在所有并发执行的所有类型的insert语句中是唯一且单调递增的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），为任何给定语句插入的行生成的值可能不是连续的。</p><h4 id="1-4、元数据锁（MDL锁）"><a href="#1-4、元数据锁（MDL锁）" class="headerlink" title="1.4、元数据锁（MDL锁）"></a>1.4、元数据锁（MDL锁）</h4><p> MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p><h3 id="2-InnoDB中的行锁"><a href="#2-InnoDB中的行锁" class="headerlink" title="2. InnoDB中的行锁"></a>2. InnoDB中的行锁</h3><h4 id="1-1、记录锁（Record-Locks）"><a href="#1-1、记录锁（Record-Locks）" class="headerlink" title="1.1、记录锁（Record Locks）"></a>1.1、记录锁（Record Locks）</h4><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为： <code>LOCK_REC_NOT_GAP</code> 。比如我们把id值为8的 那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p><h4 id="1-2、间隙锁（Gap-Lock）"><a href="#1-2、间隙锁（Gap-Lock）" class="headerlink" title="1.2、间隙锁（Gap Lock）"></a>1.2、间隙锁（Gap Lock）</h4><p>MySQL在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读 取操作时，那些幻影记录尚不存在，我们无法给这些 幻影记录 加上 记录锁 。InnoDB提出了一种称之为 Gap Locks 的锁，官方的类型名称为：<code>LOCK_GAP</code> ，我们可以简称为 gap锁 。比如，把id值为8的那条 记录加一个gap锁的示意图如下。</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925180137364.png" alt="image-20220925180137364"></p><h4 id="1-3、-临键锁（Next-Key-Locks）"><a href="#1-3、-临键锁（Next-Key-Locks）" class="headerlink" title="1.3、 临键锁（Next-Key Locks）"></a>1.3、 临键锁（Next-Key Locks）</h4><p>有时候我们既想锁住某条记录 ，又想阻止其他事务在该记录前边的间隙插入新记录 ，所以InnoDB就提 出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： <code>LOCK_ORDINARY</code> ，我们也可以简称为 next-key锁 。Next-Key Locks是在存储引擎 innodb 、事务级别在 可重复读 的情况下使用的数据库锁， <strong>innodb默认的锁就是Next-Key locks</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span>;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;=</span><span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><h4 id="1-4、插入意向锁（Insert-Intention-Locks）"><a href="#1-4、插入意向锁（Insert-Intention-Locks）" class="headerlink" title="1.4、插入意向锁（Insert Intention Locks）"></a>1.4、插入意向锁（Insert Intention Locks）</h4><p>我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 （ next-key锁 也包含 gap锁 ），如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是InnoDB规 定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个 间隙 中 插入 新记录，但是 现在在等待。InnoDB就把这种类型的锁命名为 Insert Intention Locks ，官方的类型名称为： <code>LOCK_INSERT_INTENTION</code>，我们称为 插入意向锁 。插入意向锁是一种 Gap锁 ，不是意向锁，在insert 操作时产生。</p><p>插入意向锁是在插入一条记录行前，由 INSERT 操作产生的一种间隙锁 。</p><p>事实上<strong>插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</strong>。</p><h3 id="3、页锁"><a href="#3、页锁" class="headerlink" title="3、页锁"></a>3、页锁</h3><h3 id="4、全局锁"><a href="#4、全局锁" class="headerlink" title="4、全局锁"></a>4、全局锁</h3><p>全局锁就是对 整个数据库实例 加锁。当你需要让整个库处于 只读状态 的时候，可以使用这个命令，之后 其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结 构等）和更新类事务的提交语句。全局锁的典型使用 场景 是：做 全库逻辑备份 。 全局锁的命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Flush <span class="hljs-keyword">tables</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">lock</span><br></code></pre></td></tr></table></figure><h2 id="从对待锁的态度划分-乐观锁、悲观锁"><a href="#从对待锁的态度划分-乐观锁、悲观锁" class="headerlink" title="从对待锁的态度划分:乐观锁、悲观锁"></a>从对待锁的态度划分:乐观锁、悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h2 id="按加锁的方式划分：显式锁、隐式锁"><a href="#按加锁的方式划分：显式锁、隐式锁" class="headerlink" title="按加锁的方式划分：显式锁、隐式锁"></a>按加锁的方式划分：显式锁、隐式锁</h2><h3 id="1、隐式锁"><a href="#1、隐式锁" class="headerlink" title="1、隐式锁"></a>1、隐式锁</h3><ul><li><strong>情景一：</strong>对于聚簇索引记录来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务 id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是 当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的 trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态 （也就是为自己也创建一个锁结构， is_waiting 属性是 true ）。</li><li><strong>情景二</strong>：对于二级索引记录来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如 果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已 经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记 录，然后再重复 情景一 的做法。</li></ul><p>隐式锁的逻辑过程如下： </p><p>A. InnoDB的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+Tree中。</p><p>B. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务(未提交或回滚)。如果是活 动的事务，首先将 隐式锁 转换为 显式锁 (就是为该事务添加一个锁)。 </p><p>C. 检查是否有锁冲突，如果有冲突，创建锁，并设置为waiting状态。如果没有冲突不加锁，跳到E。 </p><p>D. 等待加锁成功，被唤醒，或者超时。 </p><p>E. 写数据，并将自己的trx_id写入trx_id字段。</p><h3 id="2、显式锁"><a href="#2、显式锁" class="headerlink" title="2、显式锁"></a>2、显式锁</h3><p>通过特定的语句进行加锁，我们一般称之为显示加锁，例如： 显示加共享锁：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">select</span> .... <span class="hljs-keyword">lock</span> <span class="hljs-keyword">in</span> share mode<br></code></pre></td></tr></table></figure><p>显示加排它锁：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">select</span></span> .... <span class="hljs-keyword">for</span> update<br></code></pre></td></tr></table></figure><h1 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h1><p>关于MySQL锁的监控，我们一般可以通过检查InnoDB_row_lock 等状态变量来分析系统上的行锁的争夺情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;innodb_row_lock%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925194657695.png" alt="image-20220925194657695"></p><p>对各个状态量的说明如下：</p><ul><li>Innodb_row_lock_current_waits：当前正在等待锁定的数量； </li><li>Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长） </li><li>Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长） </li><li>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间； </li><li>Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</li></ul><h2 id="其他监控方法"><a href="#其他监控方法" class="headerlink" title="其他监控方法"></a>其他监控方法</h2><p>MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是 INNODB_TRX 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。 </p><p>MySQL5.7及之前 ，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。 </p><p>MySQL8.0删除了information_schema.INNODB_LOCKS，添加了 performance_schema.data_locks ，可 以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同， performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。</p><p>同时，information_schema.INNODB_LOCK_WAITS也被 performance_schema.data_lock_waits 所代替。</p><pre><code class=" mermaid">graph LRE(MySQL5.7)--&gt;F(MySQL8.0)A(information_schema.INNODB_LOCKS)--&gt;B(performance_schema.data_locks)C(information_schema.INNODB_LOCK_WAITS)--&gt;D(performance_schema.data_lock_waits)</code></pre><p>（1）查询正在被锁阻塞的sql语句。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> information_schema.INNODB_TRX\G;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">trx_id：唯一事务<span class="hljs-built_in">id</span>号，只读事务和非锁事务是不会创建<span class="hljs-built_in">id</span>的。<br>TRX_WEIGHT：事务的高度，代表修改的行数（不一定准确）和被事务锁住的行数。为了解决死锁，innodb会选择一个高度最小的事务来当做牺牲品进行回滚。已经被更改的非交易型表的事务权重比其他事务高，即使改变的行和锁住的行比其他事务低。<br>TRX_STATE：事务的执行状态，值一般分为：RUNNING, LOCK WAIT, ROLLING BACK, and COMMITTING.<br>TRX_STARTED：事务的开始时间<br>TRX_REQUESTED_LOCK_ID:如果trx_state是lockwait,显示事务当前等待锁的<span class="hljs-built_in">id</span>，不是则为空。想要获取锁的信息，根据该lock_id，以innodb_locks表中lock_id列匹配条件进行查询，获取相关信息。<br>TRX_WAIT_STARTED：如果trx_state是lockwait,该值代表事务开始等待锁的时间；否则为空。<br>TRX_MYSQL_THREAD_ID：mysql线程<span class="hljs-built_in">id</span>。想要获取该线程的信息，根据该thread_id，以INFORMATION_SCHEMA.PROCESSLIST表的<span class="hljs-built_in">id</span>列为匹配条件进行查询。<br>TRX_QUERY：事务正在执行的sql语句。<br>TRX_OPERATION_STATE：事务当前的操作状态，没有则为空。<br>TRX_TABLES_IN_USE：事务在处理当前sql语句使用innodb引擎表的数量。<br>TRX_TABLES_LOCKED：当前sql语句有行锁的innodb表的数量。（因为只是行锁，不是表锁，表仍然可以被多个事务读和写）<br>TRX_LOCK_STRUCTS：事务保留锁的数量。<br>TRX_LOCK_MEMORY_BYTES：在内存中事务索结构占得空间大小。<br>TRX_ROWS_LOCKED：事务行锁最准确的数量。这个值可能包括对于事务在物理上存在，实际不可见的删除标记的行。<br>TRX_ROWS_MODIFIED：事务修改和插入的行数<br>TRX_CONCURRENCY_TICKETS：该值代表当前事务在被清掉之前可以多少工作，由 innodb_concurrency_tickets系统变量值指定。<br>TRX_ISOLATION_LEVEL：事务隔离等级。<br>TRX_UNIQUE_CHECKS：当前事务唯一性检查启用还是禁用。当批量数据导入时，这个参数是关闭的。<br>TRX_FOREIGN_KEY_CHECKS：当前事务的外键坚持是启用还是禁用。当批量数据导入时，这个参数是关闭的。<br>TRX_LAST_FOREIGN_KEY_ERROR：最新一个外键错误信息，没有则为空。<br>TRX_ADAPTIVE_HASH_LATCHED：自适应哈希索引是否被当前事务阻塞。当自适应哈希索引查找系统分区，一个单独的事务不会阻塞全部的自适应<span class="hljs-built_in">hash</span>索引。自适应<span class="hljs-built_in">hash</span>索引分区通过 innodb_adaptive_hash_index_parts参数控制，默认值为8。<br>TRX_ADAPTIVE_HASH_TIMEOUT：是否为了自适应<span class="hljs-built_in">hash</span>索引立即放弃查询锁，或者通过调用mysql函数保留它。当没有自适应<span class="hljs-built_in">hash</span>索引冲突，该值为0并且语句保持锁直到结束。在冲突过程中，该值被计数为0，每句查询完之后立即释放门闩。当自适应<span class="hljs-built_in">hash</span>索引查询系统被分区（由 innodb_adaptive_hash_index_parts参数控制），值保持为0。<br>TRX_IS_READ_ONLY：值为1表示事务是<span class="hljs-built_in">read</span> only。<br>TRX_AUTOCOMMIT_NON_LOCKING：值为1表示事务是一个select语句，该语句没有使用<span class="hljs-keyword">for</span> update或者shared mode锁，并且执行开启了autocommit，因此事务只包含一个语句。当TRX_AUTOCOMMIT_NON_LOCKING和TRX_IS_READ_ONLY同时为1，innodb通过降低事务开销和改变表数据库来优化事务。<br></code></pre></td></tr></table></figure><p>（2）查询锁的情况</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">SELECT * <span class="hljs-keyword">from</span> performance_schema.data_locks<span class="hljs-string">\G;</span><br></code></pre></td></tr></table></figure><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs inform7">ENGINE：持有或请求锁定的存储引擎<br>ENGINE_LOCK_ID：存储引擎持有或请求的锁的ID，锁ID格式是内部的，随时可能更改。<br>ENGINE_TRANSACTION_ID：请求锁定的事务存储引擎内部ID，可以将其视为锁的所有者<br>THREAD_ID：对应事务的线程ID，如果需要获取更详细的信息，需要关联threads表的THREAD_ID<br>EVENT_ID：指明造成锁的EVENT_ID，THREAD_ID+EVENT_ID对应parent EVENT，可以在以下几张表内获得信息<br>events_waits_xx表查看等待事件<br>events_stages_xxx查看到了哪个阶段<br>events_statements_xx表查看对应的SQL语句<br>events_transactions_current对应查看事务信息<br>OBJECT_SCHEMA：对应锁表的schema名称<br>OBJECT_NAME：对应锁的表名<br>PARTITION_NAME：对应锁的分区名<br>SUBPARTITION_NAME：对应锁的子分区名<br>INDEX_NAME：锁对应的索引名称，InnoDB表不会为NULL<br>OBJECT_INSTANCE_BEGIN：锁对应的内存地址<br>LOCK_TYPE：对应的锁类型，对InnoDB而言，可为表锁或者行锁<br>LOCK_MODE：锁模式，对应值可能为S<span class="hljs-comment">[,GAP]</span>, X<span class="hljs-comment">[, GAP]</span>, <span class="hljs-keyword">IS</span><span class="hljs-comment">[,GAP]</span>, IX<span class="hljs-comment">[,GAP]</span>, AUTO_INC和UNKNOWN<br>LOCK_STATUS：锁状态，可能为GRANTED或者WAITING<br>LOCK_DATA：锁对应的数据，例如如果锁定的是主键，那么该列对应的就是加锁的主键值<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- col1为辅助索引，索引名为c</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> test.col1<span class="hljs-operator">&gt;=</span><span class="hljs-number">10</span> <span class="hljs-keyword">and</span> test.col1<span class="hljs-operator">&lt;</span><span class="hljs-number">11</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925201840219.png" alt="image-20220925201840219"></p><p>（3）查询锁等待情况</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> data_lock_waits\G;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ENGINE：请求的锁的引擎<br>REQUESTING_ENGINE_LOCK_ID：请求的锁在存储引擎中的锁ID<br>REQUESTING_ENGINE_TRANSACTION_ID：请求锁的事务对应的事务ID<br>REQUESTING_THREAD_ID：请求锁的线程ID<br>REQUESTING_EVENT_ID：请求锁的EVENT ID<br>REQUESTING_OBJECT_INSTANCE_BEGIN：请求的锁的内存地址<br><span class="hljs-keyword">BLOCKING_ENGINE_LOCK_ID：阻塞的锁的ID，对应data_locks表的ENGINE_LOCK_ID列</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BLOCKING_ENGINE_TRANSACTION_ID：锁阻塞的事务ID</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BLOCKING_THREAD_ID：锁阻塞的线程ID</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BLOCKING_EVENT_ID：锁阻塞的EVENT </span>ID<br><span class="hljs-keyword">BLOCKING_OBJECT_INSTANCE_BEGIN：阻塞的锁内存地址</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">insert</span> into test values(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220925201633279.png" alt="image-20220925201633279"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Queue</title>
    <link href="/2022/09/09/Queue/"/>
    <url>/2022/09/09/Queue/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h1><p>ArrayDeque基于数组实现双端队列，采用head和tail标志队列的头和位，当队列满时，再扩容（两倍）底层的数组的容量；</p><h2 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h2><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst"></a>addFirst</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addFirst</span>(<span class="hljs-params">E e</span>) &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    elements[head = (head - <span class="hljs-number">1</span>) &amp; (elements.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)] = e;<br>    <span class="hljs-keyword">if</span> (head == tail)<br>        <span class="hljs-title function_">doubleCapacity</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast"></a>addLast</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    elements[tail] = e;<br>    <span class="hljs-keyword">if</span> ( (tail = (tail + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)) == head)<br>        doubleCapacity();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doubleCapacity</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">assert</span> head == tail;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> elements.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n - p; <span class="hljs-comment">// number of elements to the right of p</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> n &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 容量加倍</span><br>    <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Sorry, deque too big&quot;</span>);<br>    Object[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newCapacity];<br>    System.arraycopy(elements, p, a, <span class="hljs-number">0</span>, r);  <span class="hljs-comment">// 根据head位置将元素复制到新数组</span><br>    System.arraycopy(elements, <span class="hljs-number">0</span>, a, r, p);<br>    elements = a;<br>    head = <span class="hljs-number">0</span>;<br>    tail = n;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h1><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">优先级队列表示为一个平衡的二叉堆:queue[n]的两个子节点分别是queue[2*n+1]和queue[2*(n+1)]。如果comparator为空，PriorityQueue将按照元素的自然排序:对于堆中的每个节点n和n的每个后代d, n &lt;= d。值最小的元素在队列[0]中。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Object[] queue; <span class="hljs-comment">// non-private to simplify nested class access</span><br></code></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">offer</span>(e);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">offer</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (e == null)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">NullPointerException</span>();<br>    modCount++;<br>    <span class="hljs-type">int</span> i = size;<br>    <span class="hljs-keyword">if</span> (i &gt;= queue.length)<br>        <span class="hljs-built_in">grow</span>(i + <span class="hljs-number">1</span>); <span class="hljs-comment">//  Double size if small(oldCapacity &lt; 64); else grow by 50%</span><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="hljs-comment">                                         (oldCapacity + 2) :</span><br><span class="hljs-comment">                                         (oldCapacity &gt;&gt; 1));</span><br><span class="hljs-comment">        */</span><br>    size = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>        queue[<span class="hljs-number">0</span>] = e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">siftUp</span>(i, e);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="从下往上调整"><a href="#从下往上调整" class="headerlink" title="从下往上调整"></a>从下往上调整</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">在位置k插入项目x，通过向上提升x直到它大于或等于它的父节点，或者是根节点，来保持堆不变。为了简化和加快强制和比较。Comparable和Comparator版本被分离成不同的方法，这些方法在其他方面是相同的。</span><br><span class="hljs-comment">参数: K -要填充的位置</span><br><span class="hljs-comment"> x -要插入的项</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-literal">null</span>)<br>        siftUpUsingComparator(k, x);<br>    <span class="hljs-keyword">else</span><br>        siftUpComparable(k, x);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpComparable</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    Comparable&lt;? <span class="hljs-built_in">super</span> E&gt; key = (Comparable&lt;? <span class="hljs-built_in">super</span> E&gt;) x;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue[parent];<br>        <span class="hljs-keyword">if</span> (key.compareTo((E) e) &gt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// </span><br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        k = parent;<br>    &#125;<br>    queue[k] = key;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> queue[parent];<br>        <span class="hljs-keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// x大于父元素e则停止</span><br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        k = parent;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从上往下调整"><a href="#从上往下调整" class="headerlink" title="从上往下调整"></a>从上往下调整</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment">在k位置插入项目x，通过在树中反复降低x，直到它小于或等于它的子节点或是叶节点，来保持堆不变。 </span><br><span class="hljs-comment">参数: K -要填充的位置</span><br><span class="hljs-comment"> x -要插入的项</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (comparator != null)<br><span class="hljs-built_in">siftDownUsingComparator</span>(k, x);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">siftDownComparable</span>(k, x);<br>&#125;<br>    <br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">void</span> <span class="hljs-title">siftDownUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> half = size &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; half) &#123;<br>        <span class="hljs-type">int</span> child = (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>        Object c = queue[child];<br>        <span class="hljs-type">int</span> right = child + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right &lt; size &amp;&amp;<br>            comparator.<span class="hljs-built_in">compare</span>((E) c, (E) queue[right]) &gt; <span class="hljs-number">0</span>)<br>            c = queue[child = right];<br>        <span class="hljs-keyword">if</span> (comparator.<span class="hljs-built_in">compare</span>(x, (E) c) &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = c;<br>        k = child;<br>    &#125;<br>    queue[k] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> --size;<br>    modCount++;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) queue[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) queue[s]; <span class="hljs-comment">// x为数组最后元素</span><br>    queue[s] = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-number">0</span>)<br>        siftDown(<span class="hljs-number">0</span>, x); <span class="hljs-comment">// 将x插入到堆顶，再从上到下调整堆</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>收藏文章</title>
    <link href="/2022/08/31/%E6%94%B6%E8%97%8F%E6%96%87%E7%AB%A0/"/>
    <url>/2022/08/31/%E6%94%B6%E8%97%8F%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><a href="https://blog.csdn.net/w372426096/category_7126824.html">https://blog.csdn.net/w372426096/category_7126824.html</a></p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p><a href="https://juejin.cn/post/6985337310472568839">https://juejin.cn/post/6985337310472568839</a></p><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://imageslr.com/">https://imageslr.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2022/05/01/HashMap/"/>
    <url>/2022/05/01/HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>基于哈希表的Map接口的实现。这个实现提供了所有可选的map操作，并<strong>允许空值和空键</strong>。(HashMap类大致相当于Hashtable，只是它是非同步的，并且允许为空。)这个类<strong>不保证映射的顺序</strong>;特别是，它不能保证顺序将随时间保持不变。</p><p>这个实现为基本操作(get和put)提供了常数时间的性能，假设散列函数将元素适当地分散到存储桶中。迭代集合视图所需的时间与HashMap实例的“容量”(桶的数量)加上它的大小(键值映射的数量)成正比。因此，如果迭代性能很重要，那么初始容量不要设置得太高(或者负载因子太低)是非常重要的。</p><p>HashMap实例有两个参数影响其性能:初始容量和加载因子。容量是哈希表中桶的数量，初始容量就是创建哈希表时的容量。负载因子用于度量在自动增加哈希表的容量之前，允许哈希表达到多大程度。<strong>当哈希表中的条目数超过负载因子和当前容量的乘积时，哈希表将被重新哈希(即重新构建内部数据结构)，这样哈希表的桶数大约是原来的两倍</strong>。</p><p>一般来说，默认的负载因子(.75)在时间和空间成本之间提供了一个很好的权衡。较高的值会减少空间开销，但会增加查找成本(反映在HashMap类的大多数操作中，包括get和put)。在设置映射的初始容量时，应该考虑映射中预期的条目数量及其负载因子，以便最小化rehash操作的数量。如果初始容量大于最大条目数除以负载因子，则不会发生重新hash操作。</p><p>如果要在HashMap实例中存储许多映射，那么使用足够大的容量创建它将允许更有效地存储映射，而不是让它根据需要执行重新哈希来增长表。注意，在相同的hashCode()中使用多个键肯定会降低任何散列表的性能。为了减轻影响，当键是Comparable时，这个类可以使用键之间的比较顺序来帮助打破连接。</p><p>注意，这个实现不是同步的。如果多个线程并发访问一个散列映射，并且至少有一个线程在结构上修改该映射，则必须从外部对其进行同步。(结构修改是任何添加或删除一个或多个映射的操作;仅仅改变与一个实例已经包含的键相关联的值并不是结构上的修改。)这通常通过对自然封装映射的某些对象进行同步来完成。如果不存在这样的对象，则应该使用集合“包装”映射。synchronizedMap方法。这最好在创建时完成，以防止对map的意外非同步访问:<code>map m = Collections。synchronizedMap(new HashMap(…))</code></p><p>所有此类的“集合视图方法”返回的迭代器都是fail-fast的：如果在迭代器创建后的任何时间对映射进行了结构修改，除了通过迭代器自己的remove方法外，任何方式都可以，迭代器都会抛出ConcurrentModificationException。因此，在面对并发修改时，迭代器会快速而干净地失败，而不是冒着将来某个不确定时间出现任意的、不确定的行为的风险。请注意，迭代器的fail-fast行为不能得到保证，因为一般来说，在存在非同步的并发修改时，不可能做出任何硬保证。fail-fast迭代器以最大努力抛出ConcurrentModificationException。因此，编写依赖于此异常的正确性的程序是错误的:迭代器的快速失败行为应该只用于检测错误。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="hljs-comment"> * by either of the constructors with arguments.</span><br><span class="hljs-comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor used when none specified in constructor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for using a tree rather than list for a</span><br><span class="hljs-comment"> * bin.  Bins are converted to trees when adding an element to a</span><br><span class="hljs-comment"> * bin with at least this many nodes. The value must be greater</span><br><span class="hljs-comment"> * than 2 and should be at least 8 to mesh with assumptions in</span><br><span class="hljs-comment"> * tree removal about conversion back to plain bins upon</span><br><span class="hljs-comment"> * shrinkage.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The bin count threshold for untreeifying a (split) bin during a</span><br><span class="hljs-comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span><br><span class="hljs-comment"> * most 6 to mesh with shrinkage detection under removal.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span><br><span class="hljs-comment"> * between resizing and treeification thresholds.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br></code></pre></td></tr></table></figure><h1 id="添加put"><a href="#添加put" class="headerlink" title="添加put"></a>添加put</h1><h2 id="计算hash值"><a href="#计算hash值" class="headerlink" title="计算hash值"></a>计算hash值</h2><p>计算key.hashCode()并将较高的哈希值扩展为较低的哈希值。由于该表使用了二的幂掩码，因此仅在当前掩码之上位不同的哈希集总是会发生碰撞。(已知的例子包括在小表中保存连续整数的Float键集。)因此，我们应用一个变换，将更高位的影响向下传播。比特传播的速度、效用和质量之间需要权衡。因为许多常见的哈希集已经合理地分布了(所以不能从扩展中获益)，而且因为我们使用树来处理bin中的大型碰撞集，所以我们只是以最便宜的方式异或一些移位的位，以减少系统损失，以及合并最高位的影响，否则由于表边界的原因，索引计算中永远不会使用最高位。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="插入元素put-k-v"><a href="#插入元素put-k-v" class="headerlink" title="插入元素put(k,v)"></a>插入元素put(k,v)</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs arcade">final V putVal(int <span class="hljs-built_in">hash</span>, K key, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>               <span class="hljs-built_in">boolean</span> evict) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) == <span class="hljs-literal">null</span> || (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) == <span class="hljs-number">0</span>)<br>        n = (<span class="hljs-literal">tab</span> = <span class="hljs-built_in">resize</span>()).<span class="hljs-built_in">length</span>;<br>    <span class="hljs-keyword">if</span> ((p = <span class="hljs-literal">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) == <span class="hljs-literal">null</span>)<br>    <span class="hljs-comment">// 桶内没有元素，直接放</span><br>        <span class="hljs-literal">tab</span>[i] = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>            <span class="hljs-comment">// 在桶处替换</span><br>            e = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 链表尾部，直接插入新值</span><br>                    p.next = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 并判断是否需要树化，其中还要判断数组长度是否超过64，否则就扩容</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(<span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-comment">// 找到相等的key，需要替换</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-built_in">resize</span>();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩容resize"><a href="#扩容resize" class="headerlink" title="扩容resize()"></a>扩容resize()</h2><p>初始化或加倍表大小。<br>如果为空，根据字段阈值中持有的初始容量目标进行分配。否则，因为我们使用的是二次方展开，每个bin中的元素要么保持在相同的索引，要么在新表中以二次方的偏移量移动。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs haxe">final Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    int oldThr = threshold;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>        <span class="hljs-comment">// 容量达最大值，直接返回，不扩容</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 容量翻倍，阈值翻倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// initial capacity was placed in threshold  通过指定容量创建HashMap时，计算大于指定值的2的次方的数，存放在threshold，而在此处真正初始化容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <br>    <span class="hljs-comment">//初始化容量=16和阈值16*0.75 zero initial threshold signifies using defaults</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?<br>                  (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    @SuppressWarnings(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 原数组不为空，不是初始化，需要重新哈希</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 该bucket 有元素</span><br>                oldTab[j] = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 释放原tab，供垃圾回收</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList和LinkedList</title>
    <link href="/2022/05/01/ArrayList%E5%92%8CLinkedList/"/>
    <url>/2022/05/01/ArrayList%E5%92%8CLinkedList/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h1><h2 id="继承和实现关系"><a href="#继承和实现关系" class="headerlink" title="继承和实现关系"></a>继承和实现关系</h2><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>集合层次结构中的<em>根界面</em> 。 集合表示一组被称为其<em>元素</em>的对象。  一些集合允许重复元素，而其他集合不允许。 有些被命令和其他无序。  JDK不提供此接口的任何<em>直接</em>实现：它提供了更具体的子接口的实现，如<code>Set</code>和<code>List</code>  。 该界面通常用于传递集合，并在需要最大的通用性的情况下对其进行操作。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220501131850242.png" alt="image-20220501131850242" style="zoom: 50%;" /><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>有序集合(也称为序列)。此界面的用户可以精确控制每个元素在列表中的插入位置。用户可以通过元素的整数索引(在列表中的位置)访问元素，并在列表中搜索元素。<br>与集合不同，列表通常允许重复元素。更正式地说，列表通常允许成对的元素e1和e2，使得e1.equals(E2)，并且它们通常允许多个空元素，如果它们完全允许空元素的话。当用户尝试插入时，有人可能希望通过抛出运行时异常来实现禁止重复的列表，这并不是不可想象的，但我们预计这种用法很少。<br>除了在Collection接口中指定的约定之外，List接口还对迭代器、Add、Remove、Equals和hashCode方法的约定施加了额外的规定。为方便起见，此处还包括了其他继承方法的声明。</p><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220501132738290.png" alt="image-20220501132738290" style="zoom:50%;" /><h4 id="列表迭代器"><a href="#列表迭代器" class="headerlink" title="列表迭代器"></a>列表迭代器</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>继承2自Iterator迭代器。用于列表的迭代器，允许程序员在任一方向上遍历列表，在迭代期间修改列表，并获得迭代器在列表中的当前位置。ListIterator没有当前元素；它的光标位置始终位于调用Previous()将返回的元素和调用Next()将返回的元素之间。长度为n的列表的迭代器有n+1个可能的光标位置，如下面的插入符号(^)所示：</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220501133805550.png" alt="image-20220501133805550"></p><p>请注意，Remove和Set(Object)方法不是根据光标位置定义的；它们被定义为对调用Next或Preval()返回的最后一个元素进行操作。</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220501133856056.png" alt="image-20220501133856056"></p><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">void</span> testListIterator()&#123;<br>    List&lt;<span class="hljs-type">Integer</span>&gt; list=<span class="hljs-built_in">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        list.<span class="hljs-keyword">add</span>(i);<br>    &#125;<br>    ListIterator&lt;<span class="hljs-type">Integer</span>&gt; listIterator=list.listIterator();<br>    <span class="hljs-keyword">while</span> (listIterator.hasNext())&#123;<br>    // 从前往后，输出两个连续的元素<br>        <span class="hljs-keyword">if</span> (listIterator.hasPrevious()) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(listIterator.previous() + &quot;,  &quot;);<br>            listIterator.next();<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(listIterator.next());<br>    &#125;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;<br>    //从后往前，修改并插入元素，同时输出<span class="hljs-keyword">index</span><br>    <span class="hljs-keyword">while</span> (listIterator.hasPrevious())&#123;<br>        listIterator.previous();<br>        listIterator.<span class="hljs-keyword">set</span>(x++);<br>        listIterator.<span class="hljs-keyword">add</span>(x);<br>        listIterator.previous();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;index: &quot;+listIterator.previousIndex());<br>    &#125;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220908112421614.png" alt="image-20220908112421614" style="zoom:50%;" /><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Default initial capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared empty array instance used for empty instances.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared empty array instance used for default sized empty instances. We</span><br><span class="hljs-comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span><br><span class="hljs-comment"> * first element is added.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="hljs-comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="hljs-comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class="hljs-comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> initialCapacity</span>)</span> &#123;<br><span class="hljs-comment">// initialCapacity小于10，在第一次添加时，依然会扩容为10</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty list with an initial capacity of ten.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 懒加载，标识初始容量为10</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span>()</span> &#123;<br>    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br><span class="hljs-comment">//确保容量足够，（1）初始时，变为10；（2）size+1&gt;elementData.length时，扩容为1.5倍</span><br>    <span class="hljs-built_in">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="grow"><a href="#grow" class="headerlink" title="grow"></a>grow</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    int oldCapacity = elementData.length;<br>    <span class="hljs-comment">// 扩容为原容量的1.5倍</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220501123537574.png" alt="image-20220501123537574" style="zoom:50%;" /><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs applescript">transient int size = <span class="hljs-number">0</span>;<br><br>/**<br> * Pointer <span class="hljs-keyword">to</span> <span class="hljs-keyword">first</span> node.<br> * Invariant: (<span class="hljs-keyword">first</span> == null &amp;&amp; <span class="hljs-keyword">last</span> == null) ||<br> *            (<span class="hljs-keyword">first</span>.prev == null &amp;&amp; <span class="hljs-keyword">first</span>.<span class="hljs-built_in">item</span> != null)<br> */<br>transient Node&lt;E&gt; <span class="hljs-keyword">first</span>;<br><br>/**<br> * Pointer <span class="hljs-keyword">to</span> <span class="hljs-keyword">last</span> node.<br> * Invariant: (<span class="hljs-keyword">first</span> == null &amp;&amp; <span class="hljs-keyword">last</span> == null) ||<br> *            (<span class="hljs-keyword">last</span>.next == null &amp;&amp; <span class="hljs-keyword">last</span>.<span class="hljs-built_in">item</span> != null)<br> */<br>transient Node&lt;E&gt; <span class="hljs-keyword">last</span>;<br></code></pre></td></tr></table></figure><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><p>调用addLast</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">void linkLast(E e) &#123;<br>    final Node&lt;E&gt; l = last;<br>    final Node&lt;E&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    last = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    <span class="hljs-keyword">else</span><br>        l.next = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统原理</title>
    <link href="/2022/04/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <url>/2022/04/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="事务的4大特性ACID"><a href="#事务的4大特性ACID" class="headerlink" title="事务的4大特性ACID"></a>事务的4大特性ACID</h1><ol><li>原子性（Atomicity）</li></ol><p>事务是不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚</p><ol start="2"><li>一致性（Consistency）</li></ol><p>数据库在事务执行前后都保持一致性状态，此时，所有事务对同一数据的读取结果都是相同的。以银行转账事务事务为例。在事务开始之前，所有 账户余额的总额处于一致状态。在事务进行的过程中，一个账户余额减少了，而另一个账户余额尚未修改。因此，所有账户余额的总额处于不一致状态。但是当事务完成以后，账户余额的总额再次恢复到一致状态。</p><ol start="3"><li>隔离性（Isolation）</li></ol><p>一个事务所做的修改在最终提交前，对其他事务是不可见的</p><ol start="4"><li>持久性（Durability）</li></ol><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃。</p><h2 id="特性间关系"><a href="#特性间关系" class="headerlink" title="特性间关系"></a>特性间关系</h2><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况</li></ul><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220405221221827.png" alt="image-20220405221221827"></p><h1 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h1><p>并发环境下由于隔离性破坏导致的一致性问题：</p><ul><li>丢失修改，一个事务的操作被另一个事务的操作替换</li><li>脏读，一个事务读取到了另一个事务还未提交的数据</li><li>不可重复读，由于其他事务的修改，导致在当前事务内对同一数据的读取结果不同</li><li>幻读，由于其他事务的添加或者删除，导致在当前事务内对同一数据库的读取结果不同，会多一行或者少一行</li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h2><ul><li>行级锁</li><li>表级锁</li></ul><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ol><li>互斥锁，简写为X锁，又称写锁</li><li>共享锁，简写为S锁，又称读锁</li></ol><p>原则：</p><ol><li>一个事务对一个数据对象加了X锁，则其他事务不能对该对象加任何锁</li><li>一个事务对一个数据对象加了S锁，则其他事务不能对该对象加X锁，但可加S锁</li></ol><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>背景：当事务想对表加X锁时，需要检测是否表内的某行已经加了锁，因此引入表级的意向锁。事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X&#x2F;IX&#x2F;S&#x2F;IS 锁。</p><p>兼容类型（表级）：</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220405224215307.png" alt="image-20220405224215307"></p><p>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><ol><li>一级。事务 T 要修改数据 A 时必须<strong>加 X 锁</strong>，直到 <strong>T 结束才释放锁</strong>。解决丢失修改问题。</li><li>二级。在一级的基础上，要求读取数据 A 时必须<strong>加 S 锁</strong>，<strong>读取完马上释放 S 锁</strong>。解决脏读问题，要读取时如果有X锁则不能读。</li><li>三级。在二级的基础上，要求读取数据 A 时必须<strong>加 S 锁</strong>，直到<strong>事务结束了才能释放 S 锁</strong>。解决不可重复读问题，因为事务结束前其他事务无法加X锁。</li></ol><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><p>定义：加锁和解锁分为两个阶段进行。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</p><blockquote><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p></blockquote><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><ul><li>未提交读，事务没有提交，其他事务是可见的</li><li>提交读，事务提交前，对其他事务是不可见的</li><li>可重复读，同一事务中读取同一数据的结果是一样的</li><li>可串行化，事务是串行执行的</li></ul><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220406092640069.png" alt="image-20220406092640069"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis事务</title>
    <link href="/2022/04/08/Redis%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/04/08/Redis%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过discard来放弃组队。</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220407203410324.png" alt="image-20220407203410324"></p><blockquote><ul><li><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p></li><li><p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p></li></ul></blockquote><h1 id="事务冲突问题"><a href="#事务冲突问题" class="headerlink" title="事务冲突问题"></a>事务冲突问题</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220407204318210.png" alt="image-20220407204318210"></p><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220407204355008.png" alt="image-20220407204355008"></p><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</p><h3 id="WATCH-key"><a href="#WATCH-key" class="headerlink" title="WATCH key"></a>WATCH key</h3><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p><p>取消 WATCH 命令对所有 key 的监视。<br>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了</p><h1 id="Redis事务三大特性"><a href="#Redis事务三大特性" class="headerlink" title="Redis事务三大特性"></a>Redis事务三大特性</h1><ul><li>单独的隔离操作<br>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别的概念<br>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li><li>不保证原子性<br>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据类型</title>
    <link href="/2022/04/08/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/04/08/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li><p>是二进制安全的，意味着可以存放图片或者序列化对象</p></li><li><p>最多可以存512M</p></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>Redis 操作是原子性的，因为是单线程的</p><ol><li><p>追加 append [key] [value]</p></li><li><p>获取值长度 strlen <key>获得值的长度</p></li><li><p>setnx <key><value>只有在 key 不存在时 设置 key 的值</p></li><li><p>incr <key>将 key 中储存的数字值增1,只能对数字值操作，如果为空，新增值为1</p></li><li><p>decr <key>将 key 中储存的数字值减1,只能对数字值操作，如果为空，新增值为-1</p></li><li><p>incrby &#x2F; decrby <key> &lt;步长&gt; 将 key 中储存的数字值增减。自定义步长。</p></li><li><p>mset <key1><value1><key2><value2> …..同时设置一个或多个 key-value对</p></li><li><p>mget <key1><key2><key3> ….. 同时获取一个或多个 value </p></li><li><p>msetnx <key1><value1><key2><value2> ….. 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</p><blockquote><p>原子性，有一个失败则都失败</p></blockquote></li><li><p>getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;  获得值的范围，类似java中的substring，前包，后包</p></li><li><p>setrange <key>&lt;起始位置&gt;<value>用 <value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</p></li><li><p>setex <key>&lt;过期时间&gt;<value>设置键值的同时，设置过期时间，单位秒。</p></li><li><p>getset <key><value> 以新换旧，设置了新值同时获得旧值。</p></li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220407164636985.png" alt="image-20220407164636985"></p><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220407170121018.png" alt="image-20220407170121018" style="zoom:80%;" /><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><ol><li>lpush&#x2F;rpush <key><value1><value2><value3> …. 从左边&#x2F;右边插入一个或多个值。</li><li>lpop&#x2F;rpop <key>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</li><li>rpoplpush <key1><key2>从<key1>列表右边吐出一个值，插到<key2>列表左边。</li><li>lrange <key><start><stop>按照索引下标获得元素(从左到右) 0左边第一个，-1右边第一个</li><li>lindex <key><index>按照索引下标获得元素(从左到右)</li><li>llen <key>获得列表长度</li><li>linsert <key> before <value><newvalue>在<value>的后面插入<newvalue>插入值</li><li>lrem <key><n><value>从左边删除n个value(从左到右)</li><li>lset<key><index><value>将列表key下标为index的值替换成value</li></ol><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><ol><li>sadd <key><value1><value2> …..将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li>smembers <key>取出该集合的所有值。</li><li>sismember <key><value>判断集合<key>是否为含有该<value>值，有1，没有0</li><li>scard<key>返回该集合的元素个数。</li><li>srem <key><value1><value2> …. 删除集合中的某个元素。</li><li>spop <key><strong>随机</strong>从该集合中吐出一个值。</li><li>srandmember <key><n>随机从该集合中取出n个值。<strong>不会从集合中删除</strong> 。</li><li>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合</li><li>sinter <key1><key2>返回两个集合的交集元素。</li><li>sunion <key1><key2>返回两个集合的并集元素。</li><li>sdiff <key1><key2>返回两个集合的差集元素(key1中的，不包含key2中的)</li></ol><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><h2 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h2><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h2 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h2><ol><li>hset <key><field><value>给<key>集合中的 <field>键赋值<value></li><li>hget <key1><field>从<key1>集合<field>取出 value</li><li>hmset <key1><field1><value1><field2><value2>… 批量设置hash的值</li><li>hexists<key1><field>查看哈希表 key 中，给定域 field 是否存在。</li><li>hkeys <key>列出该hash集合的所有field</li><li>hvals <key>列出该hash集合的所有value</li><li>hincrby <key><field><increment>为哈希表 key 中的域 field 的值加上增量</li><li>hsetnx <key><field><value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当field 不存在</li></ol><h1 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h1><h2 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h2><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。<br>zset底层使用了两个数据结构<br>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。<br>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p><p><img src="https://halo-1306111927.cos.ap-beijing.myqcloud.com/halo-blog/image-20220407181913511.png" alt="image-20220407181913511"></p><p>从第2层开始，1节点比51节点小，向后比较。<br>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><h2 id="命令-4"><a href="#命令-4" class="headerlink" title="命令"></a>命令</h2><ol><li>zadd <key><score1><value1><score2><value2>…将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li><li>zrange <key><start><stop> [WITHSCORES]返回有序集 key 中，下标在<start><stop>之间的元素，带WITHSCORES，可以让分数一起和值返回到结果集。</li><li>zrangebyscore key min max [withscores] [limit offset count]返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</li><li>zrevrangebyscore key maxmin [withscores] [limit offset count]同上，改为从大到小排列。</li><li>zincrby <key><increment><value> 为元素的score加上增量</li><li>zrem <key><value>删除该集合下，指定值的元素</li><li>zcount <key><min><max>统计该集合，分数区间内的元素个数</li><li>zrank <key><value>返回该值在集合中的排名，从0开始。</li></ol><h1 id="BitMaps"><a href="#BitMaps" class="headerlink" title="BitMaps"></a>BitMaps</h1><h2 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：<br>（1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。<br>（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p><h2 id="命令-5"><a href="#命令-5" class="headerlink" title="命令"></a>命令</h2><p>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（0或1）</p><p>getbit<key><offset>获取Bitmaps中某个偏移量的值</p><p>bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p><p>bitop and(or&#x2F;not&#x2F;xor) <destkey> [key…]bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><h2 id="数据结构-6"><a href="#数据结构-6" class="headerlink" title="数据结构"></a>数据结构</h2><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><h2 id="命令-6"><a href="#命令-6" class="headerlink" title="命令"></a>命令</h2><p>pfadd <key>&lt; element&gt; [element …] 添加指定元素到 HyperLogLog 中，将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0</p><p>pfcount<key> [key …] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可。</p><p>pfmerge<destkey><sourcekey> [sourcekey …] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得。</p><h1 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h1><h1 id="命令-7"><a href="#命令-7" class="headerlink" title="命令"></a>命令</h1><p>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member…] 添加地理位置（经度，纬度，名称）</p><p>geopos <key><member> [member…] 获得指定地区的坐标值</p><p>geodist<key><member1><member2> [m|km|ft|mi ] 获取两个位置之间的直线距离</p><p>georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi 以给定的经纬度为中心，找出某一半径内的元素</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unsafe</title>
    <link href="/2022/04/03/Unsafe/"/>
    <url>/2022/04/03/Unsafe/</url>
    
    <content type="html"><![CDATA[<h1 id="获取与使用"><a href="#获取与使用" class="headerlink" title="获取与使用"></a>获取与使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUnsafe</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);<br><br>        System.out.println(unsafe);<br><br>        <span class="hljs-comment">// 1. 获取域的偏移地址</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        <span class="hljs-comment">// 2. 执行 cas 操作</span><br>        unsafe.compareAndSwapInt(t, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        unsafe.compareAndSwapObject(t, nameOffset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 验证</span><br>        System.out.println(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="实现原子类"><a href="#实现原子类" class="headerlink" title="实现原子类"></a>实现原子类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNSAFE = UnsafeAccessor.getUnsafe();<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子数据</title>
    <link href="/2022/04/03/%E5%8E%9F%E5%AD%90%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/04/03/%E5%8E%9F%E5%AD%90%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h1><p><code>J.U.C </code>并发包提供了：</p><ul><li><p><code>AtomicBoolean</code></p></li><li><p><code>AtomicInteger</code></p></li><li><p><code>AtomicLong</code></p><p>以<code> AtomicInteger</code> 为例</p></li></ul><p>调用Unsafe的<code>compareAndSwapInt</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>System.out.println(i.getAndIncrement());<br><span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>System.out.println(i.incrementAndGet());<br><span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>System.out.println(i.decrementAndGet());<br><span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>System.out.println(i.getAndDecrement());<br><span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br><span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br><span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br><span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br><span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br><span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span><br><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br></code></pre></td></tr></table></figure><h1 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h1><p>调用Unsafe的<code>compareAndSwapObject</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(amount);<br>        <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h1><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用<code>AtomicStampedReference</code>或者<code>AtomicMarkableReference</code>（只有两种状态）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test36</span> &#123;<br><br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>        <span class="hljs-comment">// 获取版本号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>        log.debug(<span class="hljs-string">&quot;版本 &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span><br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>            log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, ref.getStamp(), ref.getStamp() + <span class="hljs-number">1</span>));<br>            log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h1><p>实现对数组内元素更改的线程安全</p><ul><li><code>AtomicIntegerArray</code></li><li><code>AtomicLongArray</code></li><li><code>AtomicReferenceArray</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>(array) -&gt; array.length(),<br>(array, index) -&gt; array.getAndIncrement(index),<br>array -&gt; System.out.println(array)<br>);<br></code></pre></td></tr></table></figure><h1 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h1><p>实现对类的属性更改的线程安全</p><ul><li><code>AtomicReferenceFieldUpdater </code>&#x2F;&#x2F; 域 字段</li><li><code>AtomicIntegerFieldUpdater</code></li><li><code>AtomicLongFieldUpdater</code></li></ul><blockquote><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p></blockquote><h1 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>LongAdder</code>性能比<code>AtomicLong</code>好。提升的原因很简单，就是在有竞争时，设置多个累加单元，<code>Therad-0 </code>累加<code> Cell[0]</code>，而 <code>Thread-1 </code>累加<code>Cell[1]... </code>最后将结果汇总。这样它们在累加时操作的不同的 <code>Cell</code> 变量，因此减少了<code>CAS</code>重试失败，从而提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(<br>            () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>), <span class="hljs-comment">// 使用AtomicLong进行累加</span><br>            AtomicLong::getAndIncrement<br>    );<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    demo(<br>            LongAdder::<span class="hljs-keyword">new</span>,<br>            LongAdder::increment <span class="hljs-comment">//// 使用LongAdder进行累加</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CAS锁"><a href="#CAS锁" class="headerlink" title="CAS锁"></a>CAS锁</h2><blockquote><p>不要用于实践！！！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockCas</span> &#123;<br>    <span class="hljs-comment">// 0 没加锁</span><br>    <span class="hljs-comment">// 1 加锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;unlock...&quot;</span>);<br>        state.set(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LockCas</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockCas</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;lock...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LongAdder原理"><a href="#LongAdder原理" class="headerlink" title="LongAdder原理"></a>LongAdder原理</h2><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因此缓存行可以存下 2 个的 Cell 对象。这样问题来了：<br>Core-0 要修改 Cell[0]<br>Core-1 要修改 Cell[1]</p><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，比如 Core-0 中 Cell[0]&#x3D;6000, Cell[1]&#x3D;8000 要累加Cell[0]&#x3D;6001, Cell[1]&#x3D;8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的前后各增加 128 字节大小的padding，从而让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java内存模型</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS原理与特点</title>
    <link href="/2022/04/03/CAS%E5%8E%9F%E7%90%86%E4%B8%8E%E7%89%B9%E7%82%B9/"/>
    <url>/2022/04/03/CAS%E5%8E%9F%E7%90%86%E4%B8%8E%E7%89%B9%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul><li><p><code>CAS</code> 的底层是 <code>lock cmpxchg </code>指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交<br>换】的原子性。</p></li><li><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再<br>开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子<br>的。</p></li><li><p><code>CAS</code> 必须借助 <code>volatile</code> 才能读取到共享变量的最新值来实现【比较并交换】的效果</p></li></ul><blockquote><p>注意！无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p></blockquote><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java内存模型</tag>
      
      <tag>CAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA内存模型--有序性</title>
    <link href="/2022/04/03/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B--%E6%9C%89%E5%BA%8F%E6%80%A7/"/>
    <url>/2022/04/03/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B--%E6%9C%89%E5%BA%8F%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>r.r1除了可能为1或4，由于actor2的可能指令重排，存在r.r1为0的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java|一个例子">public class ConcurrencyTest &#123;<br>    int num = 0;<br>    volatile boolean ready = false;<br>    <br>    @Actor<br>    public void actor1(I_Result r) &#123;<br>        if(ready) &#123;<br>            r.r1 = num + num;<br>        &#125; else &#123;<br>            r.r1 = 1;<br>        &#125;<br>    &#125;<br><br>    @Actor<br>    public void actor2(I_Result r) &#123;<br>        num = 2;<br>        ready = true;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li><li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 读取值带读屏障</span><br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>;<span class="hljs-comment">// ready 是 volatile 赋值带写屏障</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>但是不能解决指令交错：</li></ul><ol><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序<br><img src="/upload/2022/04/%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%8C%87%E4%BB%A4%E4%BA%A4%E9%94%99%E9%97%AE%E9%A2%98.jpg" alt="线程间指令交错问题"></li></ol><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>懒惰实例化</li><li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外<figure class="highlight plaintext"><figcaption><span>locking</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java|double-checked">if (INSTANCE == null) &#123;<br>    synchronized (Singleton.class) &#123;<br>        // 也许有其它线程已经创建实例，所以再判断一次<br>        if (INSTANCE == null) &#123;<br>            INSTANCE = new Singleton();<br>        &#125;<br>    &#125;<br>&#125;<br>return INSTANCE;<br></code></pre></td></tr></table></figure></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>关键在于 0: getstatic 这行代码在 monitor 控制之外，它就像之前举例中不守规则的人，可以越过 monitor 读取<br>INSTANCE 变量的值<br>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初<br>始化完毕的单例<br><img src="/upload/2022/04/%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%8C%87%E4%BB%A4%E4%BA%A4%E9%94%99%E9%97%AE%E9%A2%981.jpg" alt="线程间指令交错问题1"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排</p><h1 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h1><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</li><li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排</li></ul>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java内存模型</tag>
      
      <tag>并发</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA内存模型--可见性</title>
    <link href="/2022/04/03/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B--%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <url>/2022/04/03/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B--%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java|一个例子">Thread t = new Thread(() -&gt; &#123;<br>    while (true) &#123;<br>        if (!run) &#123;<br>            break;<br>        &#125;<br>    &#125;<br>&#125;);<br>t.start();<br>sleep(1);<br>run = false; // 线程t不会如预想的停下来<br></code></pre></td></tr></table></figure><p>JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率。<br>但是存在可见性问题<br><img src="/upload/2022/04/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="内存模型"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="实现两阶段终止模式"><a href="#实现两阶段终止模式" class="headerlink" title="实现两阶段终止模式"></a>实现两阶段终止模式</h2><p>两个线程，一个线程写stop标志，另外一个通过读volatile修饰的变量实现随时停止。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 监控线程</span><br><span class="hljs-keyword">private</span> Thread monitorThread;<br><span class="hljs-comment">// 停止标记</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> stop = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Balking模式"><a href="#Balking模式" class="headerlink" title="Balking模式"></a>Balking模式</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> start() &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (starting) &#123; <span class="hljs-comment">// false</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        starting = <span class="hljs-literal">true</span>;<br>    &#125;<br>    monitorThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            Thread current = Thread.currentThread();<br>            <span class="hljs-comment">// 是否被打断</span><br>            <span class="hljs-keyword">if</span> (stop) &#123;<br>                log.<span class="hljs-keyword">debug</span>(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                log.<span class="hljs-keyword">debug</span>(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;monitor&quot;</span>);<br>    monitorThread.start();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java|线程安全的单例模式">public final class Singleton &#123;<br>    private Singleton() &#123;<br>    &#125;<br><br>    private static volatile Singleton INSTANCE = null;<br><br>    public static Singleton getInstance() &#123;<br>        // 实例没创建，才会进入内部的 synchronized代码块<br>        /*if (INSTANCE == null) &#123;<br>            synchronized (Singleton.class) &#123;<br>                // 也许有其它线程已经创建实例，所以再判断一次<br>                if (INSTANCE == null) &#123;<br>                    INSTANCE = new Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        return INSTANCE;*/<br><br><br>        if (INSTANCE != null) &#123;<br>            return INSTANCE;<br>        &#125;<br>        synchronized (Singleton.class) &#123;<br>            // 也许有其它线程已经创建实例，所以再判断一次<br>            if (INSTANCE == null) &#123;<br>                INSTANCE = new Singleton();<br>            &#125;<br>            return INSTANCE;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java内存模型</tag>
      
      <tag>并发</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重入锁</title>
    <link href="/2022/04/02/%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <url>/2022/04/02/%E9%87%8D%E5%85%A5%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ul><li>可重入</li><li>可实现公平锁（并发度降低）</li><li>可被打断（避免死锁的一种方式）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java|可被打断">//竞争锁，可能进入等待，但是其他方法可通过中断唤醒该线程<br>lock.lockInterruptibly(); <br>// 打断并抛出中断异常InterruptedException<br>t1.interrupt();<br></code></pre></td></tr></table></figure></li><li>实现锁超时<br>  可自己释放锁<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java|可自己释放锁">Thread t1 = new Thread(() -&gt; &#123;<br>    log.debug(&quot;尝试获得锁&quot;);<br>    try &#123;<br>        if (!lock.tryLock(2, TimeUnit.SECONDS)) &#123;<br>            log.debug(&quot;获取不到锁&quot;);<br>            return;<br>        &#125;<br>    &#125; catch (InterruptedException e) &#123;<br>        e.printStackTrace();<br>        log.debug(&quot;获取不到锁&quot;);<br>        return;<br>    &#125;<br>    try &#123;<br>        log.debug(&quot;获得到锁&quot;);<br>    &#125; finally &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;, &quot;t1&quot;);<br><br>lock.lock();<br>log.debug(&quot;获得到锁&quot;);<br>t1.start();<br>sleep(1); // 主线程提前释放，t1可以获取到锁<br>log.debug(&quot;释放了锁&quot;);<br>lock.unlock();<br></code></pre></td></tr></table></figure></li><li>可以有多个条件变量<br>要点<br>await 前需要获得锁；<br>await 执行后，会释放锁，进入 conditionObject 等待；<br>await 的线程被唤醒（或打断、或超时）需重新竞争 lock 锁；<br>竞争 lock 锁成功后，从 await 后继续执行；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java|支持多个条件变量">static ReentrantLock ROOM = new ReentrantLock();<br>    // 等待烟的休息室<br>static Condition waitCigaretteSet = ROOM.newCondition();<br>    // 等外卖的休息室<br>static Condition waitTakeoutSet = ROOM.newCondition();<br><br>new Thread(() -&gt; &#123;<br>    ROOM.lock();<br>    try &#123;<br>        log.debug(&quot;有烟没？[&#123;&#125;]&quot;, hasCigarette);<br>        if (!hasCigarette) &#123;<br>            log.debug(&quot;没烟，先歇会！&quot;);<br>            try &#123;<br>                waitCigaretteSet.await();<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        log.debug(&quot;可以开始干活了&quot;);<br>    &#125; finally &#123;<br>        ROOM.unlock();<br>    &#125;<br>&#125;, &quot;小南&quot;).start();<br><br>new Thread(() -&gt; &#123;<br>    ROOM.lock();<br>    try &#123;<br>        log.debug(&quot;外卖送到没？[&#123;&#125;]&quot;, hasTakeout);<br>        if (!hasTakeout) &#123;<br>            log.debug(&quot;没外卖，先歇会！&quot;);<br>            try &#123;<br>                waitTakeoutSet.await();<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        log.debug(&quot;可以开始干活了&quot;);<br>    &#125; finally &#123;<br>        ROOM.unlock();<br>    &#125;<br>&#125;, &quot;小女&quot;).start();<br><br>sleep(1);<br><br>new Thread(() -&gt; &#123;<br>    ROOM.lock();<br>    try &#123;<br>        hasTakeout = true;<br>        waitTakeoutSet.signal();<br>    &#125; finally &#123;<br>        ROOM.unlock();<br>    &#125;<br>&#125;, &quot;送外卖的&quot;).start();<br><br>sleep(1);<br><br>new Thread(() -&gt; &#123;<br>    ROOM.lock();<br>    try &#123;<br>        hasCigarette = true;<br>        waitCigaretteSet.signal();<br>    &#125; finally &#123;<br>        ROOM.unlock();<br>    &#125;<br>&#125;, &quot;送烟的&quot;).start();<br></code></pre></td></tr></table></figure></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="解决哲学家问题"><a href="#解决哲学家问题" class="headerlink" title="解决哲学家问题"></a>解决哲学家问题</h2><p>死锁的必要条件：</p><ol><li>互斥。资源要么被分配，要么就可用。</li><li><del>占有并等待。线程已经有一个资源，但是尝试获取另外一个资源。</del></li><li>不可抢占。已经被分配的资源不能强制抢占。</li><li>环路等待。一个或两个线程存在环路。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java|哲学家就餐问题">public void run() &#123;<br>        while (true) &#123;<br>            //　尝试获得左手筷子<br>            if(left.tryLock()) &#123;<br>                try &#123;<br>                    // 尝试获得右手筷子<br>                    if(right.tryLock()) &#123;<br>                        try &#123;<br>                            eat();<br>                        &#125; finally &#123;<br>                            right.unlock();<br>                        &#125;<br>                    &#125;<br>                &#125; finally &#123;<br>                    left.unlock(); // 释放自己手里的筷子（关键）<br>                &#125;<br>            &#125;<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="实现顺序运行"><a href="#实现顺序运行" class="headerlink" title="实现顺序运行"></a>实现顺序运行</h2><p><strong>t2先运行，t1后运行</strong></p><blockquote><p>解决方案一（synchronized）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java|运行顺序">Thread t1 = new Thread(() -&gt; &#123;<br>    synchronized (lock) &#123;<br>        log.debug(&quot;1获得锁&quot;);<br>        while (!t2runned) &#123;<br>            try &#123;<br>                lock.wait();<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        log.debug(&quot;1&quot;);<br>    &#125;<br>&#125;, &quot;t1&quot;);<br><br>Thread t2 = new Thread(() -&gt; &#123;<br>    synchronized (lock) &#123;<br>        log.debug(&quot;2获得锁&quot;);<br>        log.debug(&quot;2&quot;);<br>        t2runned = true;<br>        lock.notify();<br>    &#125;<br>&#125;, &quot;t2&quot;);<br></code></pre></td></tr></table></figure><blockquote><p>解决方案二（park 与 unpark）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java|运行顺序">Thread t1 = new Thread(() -&gt; &#123;<br>    LockSupport.park();<br>    log.debug(&quot;1&quot;);<br>&#125;, &quot;t1&quot;);<br>t1.start();<br><br>new Thread(() -&gt; &#123;<br>    log.debug(&quot;2&quot;);<br>    LockSupport.unpark(t1);<br>&#125;,&quot;t2&quot;).start();<br></code></pre></td></tr></table></figure><h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h2><p><strong>线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现</strong></p><blockquote><p>解决方案一（synchronized）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java|通过synchronized实现">synchronized (this) &#123;<br>    while(flag != waitFlag) &#123;<br>        try &#123;<br>            this.wait();<br>        &#125; catch (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    System.out.print(str);<br>    flag = nextFlag;<br>    this.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解决方案二（支持多变量）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java|通过可重入锁多变量实现">class AwaitSignal extends ReentrantLock &#123;<br>    private int loopNumber;<br><br>    public AwaitSignal(int loopNumber) &#123;<br>        this.loopNumber = loopNumber;<br>    &#125;<br><br>    //            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室<br>    public void print(String str, Condition current, Condition next) &#123;<br>        for (int i = 0; i &lt; loopNumber; i++) &#123;<br>            lock();<br>            try &#123;<br>                current.await();<br>                System.out.print(str);<br>                next.signal();<br>            &#125; catch (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; finally &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解决方案三（park 与 unpark）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs `java|通过park实现">LockSupport.park();<br>System.out.print(str);<br>LockSupport.unpark(next);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>并发</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
